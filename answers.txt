# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: Phil Crumm
Student ID: 804005575
Email: pcrumm@ucla.edu

# Partner 2 (if you're working in a team)
Name: Ivan Petkov
Student ID: 704036431
Email: ipetkov@ucla.edu

# Extra credit problems
#Extra credit problem: none

# Add any other information you'd like us to know below this line.

If a file is resized so that it allocates additional blocks and nothing is
written inside of the blocks immediately, this will cause a file leak when the
file is deleted, or an I/O error the next time an attempt is made to resize
the file. Blocks are calculated based on the size of the file, thus if new
blocks are added and nothing is written, the module has no way to determine
the block has already been allocated. If the file is deleted, this block will
NOT get deallocated. This isn't an issue as Unix like files systems like OSPFS
consider it okay for block leaks, and utilities like fsck will fix this.

Such leaks will cause problems for later resizing, however, since the module
will report an I/O error if it finds a non-zero block identifier where-ever it
expects a non-allocated block. A remedy for this would be to hard copy the file
to a new destination and delete the old (and reclaim the leaked blocks with
fsck). Alternatively the module should not resize the file unless it intends
to immediately write into the new block.

When reading and writing to files with a given byte offset, an I/O error will
occur if the sum of the specified offset and the count of bytes to read
overflows. For example, if the specified offset is the max value loff_t can
hold, and 10 bytes are requested to be read or written, the file system will
report an error.

Attempting to read past the end of a file, however, will simply read 0 bytes
without signaling an I/O error. We have taken this approach as it seems to be
the expected behavior given by the default test suite.
